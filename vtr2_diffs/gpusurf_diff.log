diff --git a/3rdParty/cudpp_src_1.1.1/common/inc/cutil.h b/3rdParty/cudpp_src_1.1.1/common/inc/cutil.h
index 390b406..8bea725 100644
--- a/3rdParty/cudpp_src_1.1.1/common/inc/cutil.h
+++ b/3rdParty/cudpp_src_1.1.1/common/inc/cutil.h
@@ -744,7 +744,7 @@ extern "C" {
 
 #  define CUDA_SAFE_CALL( call) do {                                         \
     CUDA_SAFE_CALL_NO_SYNC(call);                                            \
-    cudaError err = cudaThreadSynchronize();                                 \
+    cudaError err = cudaDeviceSynchronize();                                 \
     if( cudaSuccess != err) {                                                \
         fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n",        \
                 __FILE__, __LINE__, cudaGetErrorString( err) );              \
@@ -774,7 +774,7 @@ extern "C" {
                 errorMessage, __FILE__, __LINE__, cudaGetErrorString( err) );\
         exit(EXIT_FAILURE);                                                  \
     }                                                                        \
-    err = cudaThreadSynchronize();                                           \
+    err = cudaDeviceSynchronize();                                           \
     if( cudaSuccess != err) {                                                \
         fprintf(stderr, "Cuda error: %s in file '%s' in line %i : %s.\n",    \
                 errorMessage, __FILE__, __LINE__, cudaGetErrorString( err) );\
diff --git a/CMakeLists.txt b/CMakeLists.txt
index c60d740..d81a60e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -49,21 +49,22 @@ if(${CMAKE_DEB_HOST_ARCH} MATCHES "i386")
   add_compile_options(-mno-avx)
 endif()
 
-#The arch flag is required for atomic operations.
-if((${CMAKE_DEB_HOST_ARCH} MATCHES "i386" OR ${CMAKE_DEB_HOST_ARCH} MATCHES "amd64") AND ${CUDA_VERSION} EQUAL "7.5")
-  # Most likely Lenovo laptop with NVIDIA Quadro 2200M
-  SET(CUDA_NVCC_FLAGS -arch=compute_30 -code=sm_30,sm_50 --std c++11 --default-stream per-thread)
-elseif(${CMAKE_DEB_HOST_ARCH} MATCHES "arm64" AND ${CUDA_VERSION} EQUAL "8.0")
-  # Most likely NVIDIA Tegra TX2
-  SET(CUDA_NVCC_FLAGS -arch=compute_62 -code=sm_62 --std c++11 --default-stream per-thread)
-elseif(${CMAKE_DEB_HOST_ARCH} MATCHES "armhf" AND ${CUDA_VERSION} EQUAL "6.5")
-  # Most likely NVIDIA Tegra TK1
-  SET(CUDA_NVCC_FLAGS -arch=compute_32 -code=sm_32 --std c++11 --default-stream per-thread)
-else()
-  MESSAGE(SEND_ERROR "You are building gpusurf on an architecture I haven't seen before. Please edit the compute capability of CUDA_NVCC_FLAGS manually")
-  message("CMAKE_DEB_HOST_ARCH: ${CMAKE_DEB_HOST_ARCH}")
-  message("CUDA_VERSION: ${CUDA_VERSION}")
-endif()
+# #The arch flag is required for atomic operations.
+# if((${CMAKE_DEB_HOST_ARCH} MATCHES "i386" OR ${CMAKE_DEB_HOST_ARCH} MATCHES "amd64") AND ${CUDA_VERSION} EQUAL "7.5")
+#   # Most likely Lenovo laptop with NVIDIA Quadro 2200M
+#   SET(CUDA_NVCC_FLAGS -arch=compute_30 -code=sm_30,sm_50 --std c++11 --default-stream per-thread)
+# elseif(${CMAKE_DEB_HOST_ARCH} MATCHES "arm64" AND ${CUDA_VERSION} EQUAL "8.0")
+#   # Most likely NVIDIA Tegra TX2
+#   SET(CUDA_NVCC_FLAGS -arch=compute_62 -code=sm_62 --std c++11 --default-stream per-thread)
+# elseif(${CMAKE_DEB_HOST_ARCH} MATCHES "armhf" AND ${CUDA_VERSION} EQUAL "6.5")
+#   # Most likely NVIDIA Tegra TK1
+#   SET(CUDA_NVCC_FLAGS -arch=compute_32 -code=sm_32 --std c++11 --default-stream per-thread)
+# else()
+#   MESSAGE(SEND_ERROR "You are building gpusurf on an architecture I haven't seen before. Please edit the compute capability of CUDA_NVCC_FLAGS manually")
+#   message("CMAKE_DEB_HOST_ARCH: ${CMAKE_DEB_HOST_ARCH}")
+#   message("CUDA_VERSION: ${CUDA_VERSION}")
+# endif()
+SET(CUDA_NVCC_FLAGS -arch=compute_75 -code=sm_75 --std c++11 --default-stream per-thread)
 
 SET(CUDA_VERBOSE_BUILD OFF)
 SET(CUDA_BUILD_TYPE Device)
diff --git a/src/GpuSurfDetectorInternal.cpp b/src/GpuSurfDetectorInternal.cpp
index e6f77fe..bee738c 100755
--- a/src/GpuSurfDetectorInternal.cpp
+++ b/src/GpuSurfDetectorInternal.cpp
@@ -231,7 +231,7 @@ namespace asrl {
     int ftcount = m_features.ftCount();
     GlobalTimer.start("download descriptors", ftcount);
     m_features.descriptorsMem().pullFromDevice();
-    //cudaThreadSynchronize();
+    //cudaDeviceSynchronize();
     ASRL_CHECK_CUDA_ERROR("Pull descriptors");
     //print_len(m_features.deviceDescriptors(), ftcount);
 
diff --git a/src/GpuSurfDetectorInternal.hpp b/src/GpuSurfDetectorInternal.hpp
index fae696a..d87d712 100755
--- a/src/GpuSurfDetectorInternal.hpp
+++ b/src/GpuSurfDetectorInternal.hpp
@@ -7,34 +7,34 @@
  *
  *
  */
- 
+
 /*
 Copyright (c) 2010, Paul Furgale and Chi Hay Tong
 All rights reserved.
 
-Redistribution and use in source and binary forms, with or without 
-modification, are permitted provided that the following conditions are 
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
 met:
 
-* Redistributions of source code must retain the above copyright notice, 
+* Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
-* Redistributions in binary form must reproduce the above copyright 
-  notice, this list of conditions and the following disclaimer in the 
+* Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
-* The names of its contributors may not be used to endorse or promote 
-  products derived from this software without specific prior written 
+* The names of its contributors may not be used to endorse or promote
+  products derived from this software without specific prior written
   permission.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
+TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
@@ -45,7 +45,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <opencv2/core/version.hpp>
 #if CV_MAJOR_VERSION == 2
   #include <opencv2/core/types_c.h>
-#elif CV_MAJOR_VERSION == 3
+#elif CV_MAJOR_VERSION >= 3
   #include <opencv2/core/types.hpp>
 #endif
 #include "CudaSynchronizedMemory.hpp"
@@ -135,11 +135,11 @@ namespace asrl {
      */
     void getKeypoints(std::vector<asrl::Keypoint> & outKeypoints);
 
-    /** 
+    /**
      * This pushes keypoints on to the GPU.
-     * 
+     *
      * @param inKeypoints The keypoints to be pushed on to the GPU
-     */ 
+     */
     void setKeypoints(std::vector<cv::KeyPoint> const & inKeypoints);
 
     /**
@@ -216,7 +216,7 @@ namespace asrl {
 
     /// a buffer to store the results of the interest operator calculation
     CudaSynchronizedMemory<float> m_interest;
-    
+
     /// Memory for storing histograms of interest operator scores in regions of the image.
     CudaSynchronizedMemory<unsigned int> m_histograms;
 
diff --git a/src/GpuSurfStereoDetectorInternal.cpp b/src/GpuSurfStereoDetectorInternal.cpp
index 4d5c63a..d9466fd 100644
--- a/src/GpuSurfStereoDetectorInternal.cpp
+++ b/src/GpuSurfStereoDetectorInternal.cpp
@@ -249,7 +249,7 @@ namespace asrl {
 			    m_config.stereoDisparityMinimum,   // minimum disparity
 			    m_config.stereoDisparityMaximum, // maximum disparity
 			    m_config.stereoScaleTolerance);  // scale tolerance
-    cudaThreadSynchronize();
+    cudaDeviceSynchronize();
     ASRL_CHECK_CUDA_ERROR_DBG("stereomatch");
   }
 
@@ -270,7 +270,7 @@ namespace asrl {
 
     int ftcount = m_leftFeatures.ftCount();
     m_leftFeatures.descriptorsMem().pullFromDevice();
-    cudaThreadSynchronize();
+    cudaDeviceSynchronize();
 
 
     // Resize the destination buffer.
diff --git a/src/GpuSurfStereoDetectorInternal.hpp b/src/GpuSurfStereoDetectorInternal.hpp
index 10f7f10..68fe2e9 100644
--- a/src/GpuSurfStereoDetectorInternal.hpp
+++ b/src/GpuSurfStereoDetectorInternal.hpp
@@ -8,34 +8,34 @@
  *
  *
  */
- 
+
 /*
 Copyright (c) 2010, Paul Furgale and Chi Hay Tong
 All rights reserved.
 
-Redistribution and use in source and binary forms, with or without 
-modification, are permitted provided that the following conditions are 
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
 met:
 
-* Redistributions of source code must retain the above copyright notice, 
+* Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
-* Redistributions in binary form must reproduce the above copyright 
-  notice, this list of conditions and the following disclaimer in the 
+* Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
-* The names of its contributors may not be used to endorse or promote 
-  products derived from this software without specific prior written 
+* The names of its contributors may not be used to endorse or promote
+  products derived from this software without specific prior written
   permission.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
+TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
@@ -46,7 +46,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <opencv2/core/version.hpp>
 #if CV_MAJOR_VERSION == 2
   #include <opencv2/core/types_c.h>
-#elif CV_MAJOR_VERSION == 3
+#elif CV_MAJOR_VERSION >= 3
   #include <opencv2/core/types.hpp>
 #endif
 #include "CudaSynchronizedMemory.hpp"
@@ -82,10 +82,10 @@ namespace asrl {
      */
     virtual ~GpuSurfStereoDetectorInternal();
 
-    /** 
+    /**
      * The first step in the surf pipeline. This builds an integral image from the left image argument
      * Only densly packed images images of type CV_8UC1 are supported.
-     * 
+     *
      * @param leftImage  The left image used to create the integral image.
      * @param rightImage The right image that will be used for dense stereo.
      */
@@ -126,7 +126,7 @@ namespace asrl {
      */
     void computeUprightDescriptors();
 
-    /** 
+    /**
      * Matches the keypoints between the left and right images.
      */
     void matchKeypoints();
@@ -165,46 +165,46 @@ namespace asrl {
      */
     int descriptorSize();
 
-    /** 
+    /**
      * This pushes keypoints on to the GPU.
-     * 
+     *
      * @param inKeypoints The keypoints to be pushed on to the GPU
-     */ 
+     */
     void setRightKeypoints(std::vector<cv::KeyPoint> const & inKeypoints);
 
-    /** 
+    /**
      * This pushes keypoints on to the GPU.
-     * 
+     *
      * @param inKeypoints The keypoints to be pushed on to the GPU
-     */ 
+     */
     void setRightKeypoints(std::vector<asrl::Keypoint> const & inKeypoints);
 
-    /** 
+    /**
      * This pushes descriptors on to the GPU.
-     * 
+     *
      * @param inKeypoints The descriptors to be pushed on to the GPU
-     */ 
+     */
     void setRightDescriptors(std::vector<float> const & descriptors);
 
-    /** 
+    /**
      * This pushes keypoints on to the GPU.
-     * 
+     *
      * @param inKeypoints The keypoints to be pushed on to the GPU
-     */ 
+     */
     void setLeftKeypoints(std::vector<cv::KeyPoint> const & inKeypoints);
 
-    /** 
+    /**
      * This pushes keypoints on to the GPU.
-     * 
+     *
      * @param inKeypoints The keypoints to be pushed on to the GPU
-     */ 
+     */
     void setLeftKeypoints(std::vector<asrl::Keypoint> const & inKeypoints);
 
-    /** 
+    /**
      * This pushes descriptors on to the GPU.
-     * 
+     *
      * @param inKeypoints The descriptors to be pushed on to the GPU
-     */ 
+     */
     void setLeftDescriptors(std::vector<float> const & descriptors);
 
 
@@ -242,7 +242,7 @@ namespace asrl {
 
     /// a buffer to store the results of the interest operator calculation
     CudaSynchronizedMemory<float> m_interest;
-    
+
     /// Memory for storing histograms of interest operator scores in regions of the image.
     CudaSynchronizedMemory<unsigned int> m_histograms;
 
diff --git a/src/assert_macros.hpp b/src/assert_macros.hpp
index 3b1d256..15571a9 100755
--- a/src/assert_macros.hpp
+++ b/src/assert_macros.hpp
@@ -211,7 +211,7 @@ namespace asrl {
  * 
  */
 #define ASRL_CHECK_CUDA_ERROR(errorMessage) {			\
-    cudaThreadSynchronize();						\
+    cudaDeviceSynchronize();						\
     cudaError_t err = cudaGetLastError();				\
     if( cudaSuccess != err) {						\
       std::ostringstream asrl_assert_stringstream;			\
@@ -390,7 +390,7 @@ namespace asrl {
  * 
  */
 #define ASRL_CHECK_CUDA_ERROR_DBG(errorMessage) {			\
-    cudaThreadSynchronize();						\
+    cudaDeviceSynchronize();						\
     cudaError_t err = cudaGetLastError();				\
     if( cudaSuccess != err) {						\
       std::ostringstream asrl_assert_stringstream;			\
diff --git a/src/timing.cpp b/src/timing.cpp
index be9510a..399cd20 100644
--- a/src/timing.cpp
+++ b/src/timing.cpp
@@ -17,7 +17,7 @@ Timer::~Timer()
 }
   
 void Timer::start(std::string const & tag, int N){
-  cudaThreadSynchronize();
+  cudaDeviceSynchronize();
   std::pair<unsigned,unsigned> & p = getTimer(tag);
   p.first+= N;
   cutStartTimer(p.second);
@@ -25,7 +25,7 @@ void Timer::start(std::string const & tag, int N){
 
 void Timer::stop(std::string const & tag)
 {
-  cudaThreadSynchronize();
+  cudaDeviceSynchronize();
   std::pair<unsigned,unsigned> & p = getTimer(tag);
   cutStopTimer(p.second);
 }
